import logging
import os
import sys
import traceback
from http import HTTPStatus
from logging import config
from pathlib import Path

import click

# Environment variable/s
LOGGER_USE_COLORS = os.getenv("LOGGER_USE_COLORS", "false").lower() == "true"
LOGGER_ENDPOINT_FILTERS = eval(os.getenv("LOGGER_ENDPOINT_FILTERS", "[]"))
LOGGER_STATUS_FILTERS = eval(os.getenv("LOGGER_STATUS_FILTERS", "[]"))
LOGGER_SUSPENDED_PACKAGES = eval(os.getenv("LOGGER_SUSPENDED_PACKAGES", "[]"))
LOGGER_PATH = os.getenv("LOGGER_PATH", "")

if LOGGER_PATH == "":
    LOGGER_PATH = None

# Constants
AVAILABLE_COLORS = [key for key in click.termui._ansi_colors if key != "reset"]


# Colorize text
def colorize_text(text: str, color: str, bold: bool = False) -> str:
    """
    Colorize the given text with the given color.
    If the color is not available, then the text is returned as is.
    If the color is available, then the text is colorized.
    If bold option is True, then the text is bolded.

    Parameters
    ----------
    text : str
        The text to colorize.

    color : str
        The color to use for the text.

    bold : bool
        Indicates if the text should be bolded.

    Returns
    -------
    text : str
        The colorized text.
    """
    if color not in AVAILABLE_COLORS:
        return text
    return click.style(text, fg=color, bold=bold)


# Custom filters
class EndpointFilter(logging.Filter):
    """
    This class is used to filter log messages \
    that are generated by the given path.
    """

    def __init__(self, path: str) -> None:
        """
        Initialize the filter.

        Parameters
        ----------
        path : str
            The path to filter.
        """
        super().__init__()
        self._path = path

    def filter(self, record: logging.LogRecord) -> bool:
        """
        Filter the log messages \
        if the record message contains the path path.

        Parameters
        ----------
        record : logging.LogRecord
            The log record to filter.

        Returns
        -------
        filter_check : bool
            Indicates if the log record should be filtered.
        """
        return record.getMessage().find(self._path) == -1


class StatusFilter(logging.Filter):
    """
    This class is used to filter log messages \
    that are generated by responses with the given status.
    """

    def __init__(self, status: int | str) -> None:
        """
        Initialize the filter.

        Parameters
        ----------
        status : str
            The status to filter.
        """
        super().__init__()
        if isinstance(status, str):
            status = HTTPStatus[status.upper()].value
        self._status = str(status)

    def filter(self, record: logging.LogRecord) -> bool:
        """
        Filter the log messages \
        if the record message contains the status.

        Parameters
        ----------
        record : logging.LogRecord
            The log record to filter.

        Returns
        -------
        filter_check : bool
            Indicates if the log record should be filtered.
        """
        return record.getMessage().find(self._status) == -1


class SuspensionFilter(logging.Filter):
    """
    This class is used to filter any log messages \
    that are generated by the logger using this.
    """

    def filter(self, record: logging.LogRecord) -> False:
        """
        Filter any log messages.

        Parameters
        ----------
        record : logging.LogRecord
            The log record to filter.

        Returns
        -------
        filter_check : False
            Indicates if the log record should be filtered.
        """
        return False


COMMON_FILTERS = [EndpointFilter(path) for path in LOGGER_ENDPOINT_FILTERS] + [
    StatusFilter(status) for status in LOGGER_STATUS_FILTERS
]


# Logger class
class Logger:
    """
    The core logging class for the application.
    It configures the logging settings and \
    creates a logger instance for the application.
    """

    def __init__(self) -> None:
        """
        Initialize the logger class.

        Attributes
        ----------
        _formatter : str
            The formatter for the log messages.

        _path_file_log : str | None
            The path to the log file.

        _use_colors : bool
            Indicates if the logs are colorized.
        """
        self._formatter = "(%(asctime)s) (%(pid)s) | %(levelprefix)s %(message)s"
        self._path_file_log = LOGGER_PATH
        self._use_colors = LOGGER_USE_COLORS

    def _check_file_path(self) -> None:
        """
        Check the given path is valid.
        If the path is None, then the method does nothing.
        Otherwise, this tries to create the parent directories.
        If this failes, then changes the path to None.
        """
        if self._path_file_log is None:
            return

        parents = Path(self._path_file_log).parent
        if not parents.exists():
            try:
                parents.mkdir(mode=0o777, parents=True, exist_ok=True)
            except:
                self._path_file_log = None

    def get_config(self) -> dict:
        """
        Get logging configuration.
        The configuration is used to configure the logging module.
        """
        self._check_file_path()

        config = {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "()": "src.formatters.default.DefaultFormatter",
                    "fmt": self._formatter,
                    "use_colors": self._use_colors,
                },
                "access": {
                    "()": "src.formatters.access.AccessFormatter",
                    "fmt": self._formatter,
                    "use_colors": self._use_colors,
                },
            },
            "handlers": {
                "console": {
                    "formatter": "default",
                    "class": "logging.StreamHandler",
                    "stream": "ext://sys.stdout",
                    "filters": COMMON_FILTERS,
                },
                "access": {
                    "formatter": "access",
                    "class": "logging.StreamHandler",
                    "stream": "ext://sys.stdout",
                    "filters": COMMON_FILTERS,
                },
                "suspend": {
                    "class": "logging.StreamHandler",
                    "stream": "ext://sys.stdout",
                    "filters": [SuspensionFilter()],
                },
            },
            "root": {
                "handlers": ["console"],
                "level": "INFO",
            },
            "loggers": {
                # gunicorn loggers
                "gunicorn": {"propagate": True},
                "gunicorn.info": {"propagate": True},
                "gunicorn.access": {
                    "level": "INFO",
                    "handlers": ["access"],
                    "propagate": False,
                    "qualname": "gunicorn.access",
                },
                "gunicorn.error": {"propagate": True},
                # uvicorn loggers
                "uvicorn": {"propagate": True},
                "uvicorn.access": {
                    "level": "INFO",
                    "handlers": ["access"],
                    "propagate": False,
                    "qualname": "uvicorn.access",
                },
                "uvicorn.error": {"propagate": True},
            },
        }

        if len(LOGGER_SUSPENDED_PACKAGES) > 0:
            for name in LOGGER_SUSPENDED_PACKAGES:
                config["loggers"][name] = {
                    "handlers": ["suspend"],
                    "propagate": False,
                }

        if self._path_file_log:
            self._check_file_path()
            config["handlers"].update(
                {
                    "console_file": {
                        "formatter": "default",
                        "class": "logging.handlers.RotatingFileHandler",
                        "filename": self._path_file_log,
                        "maxBytes": 1024 * 1024 * 8,
                        "backupCount": 1,
                    },
                    "access_file": {
                        "formatter": "access",
                        "class": "logging.handlers.RotatingFileHandler",
                        "filename": self._path_file_log,
                        "maxBytes": 1024 * 1024 * 8,
                        "backupCount": 1,
                        "filters": COMMON_FILTERS,
                    },
                }
            )
            config["root"]["handlers"].append("console_file")
            for key in config["loggers"]:
                if key in ("gunicorn.access", "uvicorn.access"):
                    config["loggers"][key]["handlers"].append("access_file")

        return config

    def configure(self) -> logging:
        """
        Configure the logging module.

        Returns
        -------
        logging : logging
            The configured logging module.
        """
        log_config = self.get_config()
        config.dictConfig(log_config)

        return logging


# Logger instance
LOGGER = Logger().configure()


# Logging exceptions
def log_exception(e: Exception) -> None:
    """
    Handle exceptions.
    It logs the exception and the stack trace.

    Parameters
    ----------
    e: Exception
        The exception to handle.
    """
    LOGGER.error(colorize_text(f"Exception: {repr(e)}", "red", bold=True))

    # Traceback
    ex_type, ex_value, ex_traceback = sys.exc_info()
    trace_back = traceback.extract_tb(ex_traceback)

    LOGGER.error(colorize_text(f"Exception type: {ex_type.__name__}", "yellow"))
    LOGGER.error(colorize_text(f"Exception message: {ex_value}", "yellow"))
    LOGGER.error(colorize_text("Stack trace:", "yellow"))
    for i, trace in enumerate(trace_back):
        LOGGER.error(
            colorize_text(
                (
                    f'{" " * (2 * (i + 1))}-'
                    + f'In {trace[0]}, line {trace[1]}, in function {trace[2]}: "{trace[3]}"'
                ),
                "yellow",
            )
        )
    LOGGER.error("")
